#!/usr/bin/perl
#
# USAGE:
# clusterReports.perl < cluster_input output_dir > report_output
#
# AUTHOR: justin.s.hogg
# EMAIL: justinshogg@gmail.com
# UPDATED: 2 aug 2006

# This script generates reports based on clustering results generated by
# clusterGenes.perl.  The script incorporates many types of reports, but
# there is not external user interface--you must modify the script to select
# different reports.

use warnings;
use strict;
use cgs;
use Sequence;
use SequenceList;


# set the list of strains here:

#our @STRAIN_LIST = qw ;
#our @TEMP_LIST = qw( RD 86028 R2846 R2866 UCSD01 PittEE PittGG PittHH JG167 );

#Added by Josh, the functionality to read in a strain list from a file (woot)
open (STRAIN, "strain_list")or die "can't open file!";
our @STRAIN_LIST =();

while (<STRAIN>)
{
	chomp $_;
	push(@STRAIN_LIST, $_);
}
close STRAIN;

our $TOTAL_STRAINS = scalar @STRAIN_LIST;
our $LIST_CLUSTERS = 1;




# initialize and load clusters
our @CLUSTERS = ();
our %CLUSTER_INDEX = ();
load_clusters();



# # # # # # # # # # # #
# create cluster hash #
# # # # # # # # # # # #

our %CLUSTER_HASH = ();
our %CLUSTER_LOOKUP = ();
foreach my $cluster_ref ( @CLUSTERS )
{
	#create new table in cluster hash
	my $new_table = {};
	$CLUSTER_HASH{ $cluster_ref->{name} } = $new_table;

	$CLUSTER_LOOKUP{$cluster_ref->{name}} = $cluster_ref;

	# initialize table to 0 for all strains
	foreach my $strain ( @STRAIN_LIST )
	{ $new_table->{$strain} = 0; }

	# retrieve strain info from cluster
	foreach my $gene_name ( $cluster_ref->{genes}->getNames )
	{
		my ($strain) = $gene_name =~ /^([A-Za-z0-9-]+)_/;
		next unless ( $strain );
		next unless ( grep /$strain/, @STRAIN_LIST );
		$new_table->{$strain}++;
	}

	foreach my $gene_name ( $cluster_ref->{adjuncts}->getNames )
	{
		my ($strain) = $gene_name =~ /^([A-Za-z0-9-]+)_/;
		next unless ( $strain );
		next unless ( grep /$strain/, @STRAIN_LIST );
		$new_table->{$strain}++;
	}

	foreach my $strain ( @STRAIN_LIST )
	{
		if (	$cluster_ref->{strains}->{$strain}
					and
				!$new_table->{$strain}	)
		{
			$new_table->{$strain}++;
		}
	}
} # end create cluster hash


#my $total_clusts = scalar keys %CLUSTER_HASH;
#print STDERR "total clusters: $total_clusts\n";
#foreach my $key ( keys %CLUSTER_HASH )
#{
#	print STDERR "## CLUSTER: $key\n";
#	foreach my $strain ( keys %{$CLUSTER_HASH{$key}} )
#	{
#		print STDERR "    $strain : $CLUSTER_HASH{$key}{$strain}\n";
#	}
#}
#exit;





## # # # # # # # # #
# generate reports #
# # # # # # # # # ##



# report total number of clusters generated
our $TOTAL_CLUSTERS = &totalClusters;

# report total number of core clusters (defn: clusters found in all strains)
#  and output a list of such clusters
our $CORE_CLUSTERS = &coreClusters;

# report total number of core clusters (defn: clusters found in all strains)
#  and output a list of such clusters
our $CONTIGENCY_CLUSTERS = &contingencyClusters;

# report unique clusters per strain.  Generate a list of such clusters.
&strainwiseUniqueClusters;

# report pairwise unique clusters per strain.
&pairUniqueClusters;

# report the total number of clusters per strain.  (no list of clusters.)
&clustersPerStrain;

# generate a histogram of number of genes that are found N times
&geneHistogram();

# generate clusterHash report
&generateClusterHash(\@STRAIN_LIST, "clusterHash.csv");

# make vector output for dendrogram clustering
&makeVectorOutput("cluster.vec");

# generate a pairwise comparison between strains.
&pairwiseComparison("pairwise_comparison_output.txt");


### miscellaneous reports ###

# count clobbered clusters
#&clobberedClusters( \@QUALITY_STRAINS, 2 );

#list clusters
#&listClusters();

#wiley coyote
#&wileyCoyote();

#road runner
#&roadRunner();

#elmerFudd
#&elmerFudd();

# report clusters with copy number range (min, max)
#&query_clusters( \@STRAIN_LIST, 1, 13 );
exit;


# contrast_groups( reference_strain, group1, group2, group3, min1, max1, min2, max2, min3, max3)
#my @group1 = qw( PittAA );
#my @group2 = qw(PittEE USCD01 86028 R2846 );
#my @group3 = qw( JG173 JG167 R3021 PittGG PittII R2866 );

#&contrast_groups( 'PittAA', 'PittAA_OME_set' , \@group1, \@group2, \@group3, 1, 1, 4, 4, 6, 6 );

exit 0;









# # # # # # # # # #
# cluster reports #
# # # # # # # # # #


# perform element-wise logical operations on vectors
sub vecAnd
{
	my $hash1 = shift;
	my $hash2 = shift;

	my %hash = ();

	foreach my $cluster (keys %$hash1)
	{
		if ( $hash1->{$cluster} and $hash2->{$cluster} )
		{ $hash{$cluster} = 1; }
		else
		{ $hash{$cluster} = 0; }
	}
	return \%hash;
}


sub vecOr
{
	my $hash1 = shift;
	my $hash2 = shift;

	my %hash = ();

	foreach my $cluster (keys %$hash1)
	{
		if ( $hash1->{$cluster} or $hash2->{$cluster} )
		{ $hash{$cluster} = 1; }
		else
		{ $hash{$cluster} = 0; }
	}
	return \%hash;
}


sub vecNot
{
	my $hash1 = shift @_;

	my %hash = ();

	foreach my $cluster (keys %$hash1)
	{
		if ( $hash1->{$cluster} )
		{ $hash{$cluster} = 0; }
		else
		{ $hash{$cluster} = 1; }
	}
	return \%hash;
}


#####
#####
#####


sub groupAnd
{
	my $group = shift;

	my %truthHash = ();

	foreach my $clusterName ( keys %CLUSTER_HASH )
	{
		my $cluster = $CLUSTER_HASH{$clusterName};
		my $truth = 1;

		ANDLOOP: foreach my $strain (@$group)
		{
			unless ( $cluster->{$strain} )
			{
				$truth = 0;
				last;
			}
		}
		$truthHash{$clusterName} = $truth;
	}
	return \%truthHash;
}


sub groupFuzzy
{
	my $group = shift;
	my $threshold = shift;

	my %truthHash = ();

	foreach my $clusterName ( keys %CLUSTER_HASH )
	{
		my $cluster = $CLUSTER_HASH{$clusterName};
		my $count = 0;

		foreach my $strain (@$group)
		{
			$count++ if ( $cluster->{$strain} );
		}

		if ( $count / @$group >= $threshold )
		{ $truthHash{$clusterName} = 1; }
		else
		{ $truthHash{$clusterName} = 0; }
	}
	return \%truthHash;
}


sub groupOr
{
	my $group = shift;

	my %truthHash = ();

	foreach my $clusterName ( keys %CLUSTER_HASH )
	{
		my $cluster = $CLUSTER_HASH{$clusterName};
		my $truth = 0;

		ORLOOP: foreach my $strain (@$group)
		{
			if ( $cluster->{$strain} )
			{
				$truth = 1;
				last;
			}
		}
		$truthHash{$clusterName} = $truth;
	}
	return \%truthHash;
}


#####
#####
#####


sub getResults
{
	my $hash = shift;

	my $true = 0;
	my $total = 0;

	my @list = ();

	foreach my $cluster ( keys %$hash )
	{
		$total++;
		if ( $hash->{$cluster} )
		{
			$true++;
			push @list, $cluster;
		}
	}

	return $true, $total, \@list;
}


#####
#####
#####


sub totalClusters
{
	# count all clusters
	my $clusterCount = 0;
	foreach my $cluster ( keys %CLUSTER_HASH )
	{
		$clusterCount++;
	}
	print STDOUT "<report line> total clusters: $clusterCount\n";
	return $clusterCount;
}


#####
#####
#####


sub listClusters
{
	foreach my $cluster ( keys %CLUSTER_HASH )
	{
		print STDOUT "$cluster\n";
	}
	return;
}


#####
#####
#####


sub generateClusterHash
{
	my $strainList = shift;
	my $file = shift;

	# open output file
	open FILE, ">$file"  or  die "ERROR (generateClusterHash): could not open file $file for output!\n";

	# output header
	print FILE "clusterHash\n";
	print FILE "cluster";
	foreach my $strain ( sort @$strainList )
	{
		print FILE "\t$strain";
	}
	print FILE "\n";

	foreach my $cluster ( sort keys %CLUSTER_HASH )
	{
		my $clusterRef = $CLUSTER_HASH{$cluster};
		my $lineOutput = "$cluster";
		foreach my $strain ( sort @$strainList )
		{
			if ( $clusterRef->{$strain} )
			{ $lineOutput .= "\t1";	}
			else
			{ $lineOutput .= "\t0";	}
		}
		$lineOutput .= "\n";
		print FILE $lineOutput;
	}

	close FILE;
	return;
}


#####
#####
#####


sub uniqueClusters
{
	# count clusters unique to a single strain
	my $clusterCount = 0;
	my %uniqueClusters = ();
	foreach my $cluster ( keys %CLUSTER_HASH )
	{
		my $strainCount = 0;
		my $uniqueStrain = undef;

		foreach my $strain ( keys %{$CLUSTER_HASH{$cluster}} )
		{
			if ($CLUSTER_HASH{$cluster}{$strain} > 0)
			{
				$strainCount++;
				$uniqueStrain = $strain;
			}
		}
		if ($strainCount == 1)
		{
			$clusterCount++;
			$uniqueClusters{$cluster} = $uniqueStrain;
		}
	}

	print STDOUT "totalUnique = $clusterCount\n";
	if ($LIST_CLUSTERS)
	{
		print STDOUT "<report start> total unique clusters: $clusterCount\n";
		foreach my $key ( keys %uniqueClusters )
		{
			print STDOUT "$key\t$uniqueClusters{$key}\n";
		}
		print STDOUT "<report stop>\n";
	}
	else
	{
		print STDOUT "<report line> total unique clusters: $clusterCount\n";
	}

	return;
}


#####
#####
#####


sub coreClusters
{
	# report core clusters
	my $clusterCount = 0;
	my @coreClusters = ();

	foreach my $cluster ( keys %CLUSTER_HASH )
	{
		my $strainCount = 0;
		foreach my $strain ( keys %{$CLUSTER_HASH{$cluster}} )
		{
			if ($CLUSTER_HASH{$cluster}{$strain} > 0)
			{
				$strainCount++;
			}
		}
		if ($strainCount == $TOTAL_STRAINS)
		{
			$clusterCount++;
			push @coreClusters, $cluster;
		}
	}


	if ($LIST_CLUSTERS)
	{
		print STDOUT "<report start> total core clusters: $clusterCount\n";
		foreach my $cluster ( sort @coreClusters )
		{
			print STDOUT "$cluster\n";
		}
		print STDOUT "<report stop>\n";
	}
	else
	{
		print STDOUT "<report line> total core clusters: $clusterCount\n";
	}

	return $clusterCount;
}


#####
#####
#####


sub contingencyClusters
{
	# report core clusters
	my $clusterCount = 0;
	my @contingencyClusters = ();

	foreach my $cluster ( keys %CLUSTER_HASH )
	{
		my $strainCount = 0;
		foreach my $strain ( keys %{$CLUSTER_HASH{$cluster}} )
		{
			if ($CLUSTER_HASH{$cluster}{$strain} > 0)
			{
				$strainCount++;
			}
		}
		if ($strainCount < $TOTAL_STRAINS)
		{
			$clusterCount++;
			push @contingencyClusters, $cluster;
		}
	}

	if ($LIST_CLUSTERS)
	{
		print STDOUT "<report start> total contingency clusters: $clusterCount\n";
		foreach my $cluster ( sort @contingencyClusters )
		{
			print STDOUT "$cluster\n";
		}
		print STDOUT "<report stop>\n";
	}
	else
	{
		print STDOUT "<report line> total contingency clusters: $clusterCount\n";
	}

	return $clusterCount;
}


#####
#####
#####


sub clobberedClusters
{
	# report clobbered clusters
	my $strain_list = shift;
	my $minimumStrains = shift;

	# initalize and declare local variables
	my $clusterCount = 0;
	my @clobberedClusters = ();

	foreach my $cluster ( keys %CLUSTER_HASH )
	{
		my $strainCount = 0;
		foreach my $strain ( @$strain_list )
		{
			if ( $CLUSTER_HASH{$cluster}{$strain} > 1)
			{ $strainCount++; }
		}
		if ($strainCount >= $minimumStrains )
		{
			$clusterCount++;
			push @clobberedClusters, $cluster;
		}
	}

	if ($LIST_CLUSTERS)
	{
		print STDOUT "<report start> total clobbered clusters: $clusterCount\n";
		foreach my $cluster ( @clobberedClusters )
		{
			print STDOUT "  $cluster\n";
		}
		print STDOUT "<report stop>\n";
	}
	else
	{
		print STDOUT "<report line> total clobbered clusters: $clusterCount\n";
	}

	return;
}


#####
#####
#####


sub pairUniqueClusters
{
	# report clusters unique to a pair of strains
	print STDOUT "<report start> pairUniqueClusters\n";

	my $clusterCount = 0;
	my %uniqueClusters = ();
	foreach my $cluster ( keys %CLUSTER_HASH )
	{
		my $strainCount = 0;
		my $uniqueStrain = [];
		foreach my $strain ( keys %{$CLUSTER_HASH{$cluster}} )
		{
			if ($CLUSTER_HASH{$cluster}{$strain} > 0)
			{
				$strainCount++;
				push @{$uniqueStrain}, $strain;
			}
		}
		if ($strainCount == 2)
		{
			$clusterCount++;
			$uniqueClusters{$cluster} = $uniqueStrain;
		}
	}

	print STDOUT "totalPairUnique = $clusterCount\n";
	if ($LIST_CLUSTERS)
	{
		foreach my $key ( keys %uniqueClusters )
		{
			print STDOUT "$key";
			foreach my $strain ( @{$uniqueClusters{$key}} )
			{ print STDOUT "\t$strain"; }
			print STDOUT "\n";
		}
	}
	print STDOUT "<report stop>\n";

	return;
}


#####
#####
#####


sub clustersPerStrain
{
	# report clustersPerStrain
	print STDOUT "<report start> clusters per strain\n";

	my %uniqueClusters = ();
	foreach my $strain ( @STRAIN_LIST )
	{
		my $clusterCount = 0;

		foreach my $cluster ( keys %CLUSTER_HASH )
		{
			$clusterCount++ if ( $CLUSTER_HASH{$cluster}{$strain} );
		}
		print STDOUT "$strain\t$clusterCount\n";
	}
	print STDOUT "<report stop>\n";

	return;
}


#####
#####
#####


sub pairwiseComparison
{
	# get arguments
	my $file = shift;

	# declare local variables
	my $comparison = ();
	my @tempStrains = @STRAIN_LIST;

	while (@tempStrains)
	{
		my $strain1 = shift @tempStrains;
		$comparison->{$strain1} = ();

		foreach my $strain2 ( @tempStrains )
		{
			%{$comparison->{$strain1}->{$strain2}} = (
																	'common'          => 0,
																	'common_not_core' => 0,
																	'strain1_only'    => 0,
																	'strain2_only'    => 0,
																	'difference'      => 0,
																	'comparison'      => 0,
																	'pair_unique'     => 0,
															     );

			foreach my $cluster ( keys %CLUSTER_HASH )
			{
				if ( $CLUSTER_HASH{$cluster}{$strain1} and $CLUSTER_HASH{$cluster}{$strain2} )
				{ $comparison->{$strain1}->{$strain2}->{common}++;	}
				elsif ( $CLUSTER_HASH{$cluster}{$strain1} and !$CLUSTER_HASH{$cluster}{$strain2} )
				{ $comparison->{$strain1}->{$strain2}->{strain1_only}++;	}
				elsif ( !$CLUSTER_HASH{$cluster}{$strain1} and $CLUSTER_HASH{$cluster}{$strain2} )
				{ $comparison->{$strain1}->{$strain2}->{strain2_only}++;	}

				my $total_strains = 0;
				foreach my $strain ( @STRAIN_LIST )
				{
					$total_strains++ if ( $CLUSTER_HASH{$cluster}{$strain} );
				}
				if ( $CLUSTER_HASH{$cluster}{$strain1} and $CLUSTER_HASH{$cluster}{$strain2}  and  $total_strains == 2 )
				{
					$comparison->{$strain1}->{$strain2}->{pair_unique}++;
				}
			}

			$comparison->{$strain1}->{$strain2}->{difference} = $comparison->{$strain1}->{$strain2}->{strain1_only}
																					+ $comparison->{$strain1}->{$strain2}->{strain2_only};

			$comparison->{$strain1}->{$strain2}->{comparison} = $comparison->{$strain1}->{$strain2}->{common}
																					- $comparison->{$strain1}->{$strain2}->{difference};

			$comparison->{$strain1}->{$strain2}->{common_not_core} = $comparison->{$strain1}->{$strain2}->{common}
																							- $CORE_CLUSTERS;
		} # end foreach @tempStrain
	} #end while @tempStrain


	open FILE, ">$file" || die "ERROR (pairwiseComparison): cannot open file $file for output";
	print FILE "Pairwise Comparisons\n";

	foreach my $field ( 'common','common_not_core','strain1_only','strain2_only','difference','comparison','pair_unique' )
	{
		my $index = 0;
		my $lineOut = "\nfield:\t$field\nstrain1\tstrain2\n -----\t" . join("\t", @STRAIN_LIST[1..$#STRAIN_LIST]) . "\n";
		print FILE $lineOut;

		@tempStrains = @STRAIN_LIST;
		while ( my $strain1 = shift @tempStrains )
		{
			last unless (@tempStrains);

			$lineOut = "$strain1";
			for (1..$index ) { $lineOut .= "\t"; }

			foreach my $strain2 ( @tempStrains )
			{
				$lineOut .= "\t$comparison->{$strain1}->{$strain2}->{$field}";
			}

			$lineOut .= "\n";

			print FILE $lineOut;
			$index++;
		}
	}

	return;
}


#####
#####
#####


sub strainwiseUniqueClusters
{
	# report strainwise unique clusters
	print STDOUT "<report start> unique clusters per strain\n";

	foreach my $strain1 ( @STRAIN_LIST )
	{
		my $totalUnique = 0;
		my @uniqueClusters = ();

		SULOOP: foreach my $cluster ( keys %CLUSTER_HASH )
		{
			next unless ( $CLUSTER_HASH{$cluster}{$strain1} > 0 );

			foreach my $strain2 ( @STRAIN_LIST )
			{
				next if ( $strain1 eq $strain2 );
				if ( $CLUSTER_HASH{$cluster}{$strain2} > 0 ) { next SULOOP; }
			}
			$totalUnique++;
			push @uniqueClusters, $cluster;
		}

		print STDOUT "## STRAIN: $strain1  unique_clusters: $totalUnique\n";
		if ($LIST_CLUSTERS)
		{
			foreach my $cluster ( sort @uniqueClusters )
			{ print STDOUT "$cluster\n"; }
		}

	} # end foreach @STRAIN_LIST
	print STDOUT "<report stop>\n";

	return;
}


#####
#####
#####



sub geneHistogram
{
	print STDOUT "<report start> gene copy histogram\n";
	my %histogram = ();
	
	#if there were 0 instances, the histogram didn't print out a value, this fixes that.
	my $index = 0;	
	foreach my $strain ( @STRAIN_LIST){
		$index++;
		$histogram{$index}=0;
	}
	
	foreach my $cluster ( keys %CLUSTER_HASH )
	{
		my $occurence = 0;
		foreach my $strain ( @STRAIN_LIST)
		{ $occurence++ if ( $CLUSTER_HASH{$cluster}{$strain} ); }
		$histogram{$occurence}++;
	}

	foreach my $key ( sort { $a <=> $b } keys %histogram )
	{
		print STDOUT "$key\t$histogram{$key}\n";
	}
	print STDOUT "<report stop>\n";

	return;
}


#####
#####
#####


sub wileyCoyote
{
	print STDOUT "<report 5genes>\n";
	my %histogram = ();

	foreach my $cluster ( keys %CLUSTER_HASH )
	{
		my $occurence = 0;
		foreach my $strain ( @STRAIN_LIST )
		{ $occurence++ if ( $CLUSTER_HASH{$cluster}{$strain} ); }

		if ($occurence == 9)
		{ print STDOUT "$cluster\n"; }
#		$histogram{$occurence}++;
	}

#	foreach my $key ( sort { $a <=> $b } keys %histogram )
#	{ print STDOUT "$key\t$histogram{$key}\n"; }
	print STDOUT "</report>\n";
	return;
}


#####
#####
#####


sub roadRunner
{
	print STDOUT "<report linkageDisequilibrium>\n";

	my @clusters = sort keys %CLUSTER_HASH;

	for ( my $cluster1=0; $cluster1 < @clusters; $cluster1++)
	{
		for (my $cluster2=$cluster1+1; $cluster2 < @clusters; $cluster2++ )
		{
			my $count_A = 0;
			my $count_B = 0;
			my $count_AB = 0;

			foreach my $strain ( @STRAIN_LIST )
			{
				if ( $CLUSTER_HASH{ $clusters[$cluster1] }->{$strain} and $CLUSTER_HASH{ $clusters[$cluster2] }->{$strain} )
				{
					$count_A++;
					$count_B++;
					$count_AB++;
				}
				elsif ( $CLUSTER_HASH{ $clusters[$cluster1] }->{$strain} )
				{ $count_A++; }
				elsif ( $CLUSTER_HASH{ $clusters[$cluster2] }->{$strain} )
				{ $count_B++; }
			}

			next if ( $count_A == $TOTAL_STRAINS || $count_B == $TOTAL_STRAINS );

			my $null_prob = &binomial( $TOTAL_STRAINS, $count_AB, $count_A*$count_B/$TOTAL_STRAINS**2 );
			my $linked_prob = &binomial( $TOTAL_STRAINS, $count_AB, &cgs::min( $count_A/$TOTAL_STRAINS, $count_B/$TOTAL_STRAINS ));
			my $odds_ratio = log($linked_prob/$null_prob)/log(2);

			if ($odds_ratio < 2)
			{
				print STDOUT "$clusters[$cluster1]\t$clusters[$cluster2]\t$count_A\t$count_B\t$count_AB\t$odds_ratio\n";
			}
		}
	}

	print STDOUT "</report>\n";
	return;
}


#####
#####
#####


sub elmerFudd
{
	my @strains;

	my @clusters = sort keys %CLUSTER_HASH;

	for ( my $cluster1=0; $cluster1 < @clusters; $cluster1++)
	{
		CLUSTER2LOOP: for ( my $cluster2=$cluster1+1; $cluster2 < @clusters; $cluster2++ )
		{
			foreach my $strain ( @STRAIN_LIST )
			{
				if ( $CLUSTER_HASH{ $clusters[$cluster1] }->{$strain}
						xor
					  $CLUSTER_HASH{ $clusters[$cluster2] }->{$strain} )
				{ next CLUSTER2LOOP;	}
			}

			my ($locus1) = $clusters[$cluster1] =~ /_(\d{4})_/;
			my ($locus2) = $clusters[$cluster2] =~ /_(\d{4})_/;

			next CLUSTER2LOOP unless ( abs( $locus1 - $locus2 ) < 3 );
			print STDOUT "$clusters[$cluster1]\t$clusters[$cluster2]\n";
		}
	}

	return;
}


#####
#####
#####


sub query_clusters
# find clusters with a gene copy number in a certain range
# output a representative sequence for each such cluster
{
	my $strain_list = shift;
	my $min_copies = shift;
	my $max_copies = shift;

	print STDOUT "<report start> query_clusters  min_copies: $min_copies  max_copies: $max_copies\n";

	my %strain_count = ();
	my %strain_codes = ();

	open LIST, ">", "cluster_count.csv";

	QUERYLOOP: foreach my $cluster_name ( keys %CLUSTER_HASH )
	{
		my $cluster_ref = $CLUSTER_LOOKUP{$cluster_name};
		my $copies = 0;

		foreach my $strain ( @$strain_list )
		{
			if ( $CLUSTER_HASH{$cluster_name}->{$strain} )
			{  $copies++;  }
		}

		if ( $copies <= $max_copies   and  $min_copies <= $copies )
		{

			my $code = '';
			foreach my $strain ( @$strain_list )
			{
				if ( $CLUSTER_HASH{$cluster_name}->{$strain} )
				{  $code .= '1';  }
				else
				{  $code .= '0';  }
			}

			$strain_codes{$code}++;

			my @lengths = ();
			foreach my $seq_obj ( $cluster_ref->{genes}->getAllRefs )
			{
				push @lengths, $seq_obj->len;
			}

			my $median_length = &cgs::median( \@lengths );
			my $representative;
			my $best_distance = 10000;

			foreach my $seq_obj ( $cluster_ref->{genes}->getAllRefs )
			{
				my $distance = abs( $seq_obj->len - $median_length );
				if ( $distance <= $best_distance )
				{
					$representative = $seq_obj;
					$best_distance = $distance;
				}
			}

			unless ( defined $representative )
			{
				print STDERR "ERROR: could not find representative sequence for cluster $cluster_ref!\n";
				next QUERYLOOP;
			}

			my $rep_name = $representative->name;
			print LIST "$cluster_name\t$rep_name\t$copies\n";

			$representative->writeFasta(*STDOUT{IO});
		}
	}

#	foreach my $strain ( sort keys %strain_count )
#	{
#		print STDERR "$strain\t $strain_count{$strain}\n";
#	}

#	foreach my $code ( sort { $strain_codes{$a} <=> $strain_codes{$b} } keys %strain_codes )
#	{
#		print STDERR "$code\t$strain_codes{$code}\n";
#	}

	print STDOUT "<report stop>\n";
	return;
}


#####
#####
#####


sub contrast_groups
{
	my $rep_strain = shift;
	my $strain_list1 = shift;
	my $strain_list2 = shift;
	my $strain_list3 = shift;
	my $min_copies1 = shift;
	my $max_copies1 = shift;
	my $min_copies2 = shift;
	my $max_copies2 = shift;
	my $min_copies3 = shift;
	my $max_copies3 = shift;

	print STDOUT "<report start> contrast_groups\n";
	print STDOUT "  group1: ", join(", ", @$strain_list1), "\n";
	print STDOUT "  min_copies1: $min_copies1  max_copies1: $max_copies1\n";
	print STDOUT "  group2: ", join(", ", @$strain_list2), "\n";
	print STDOUT "  min_copies2: $min_copies2  max_copies2: $max_copies2\n";
	print STDOUT "  group3: ", join(", ", @$strain_list3), "\n";
	print STDOUT "  min_copies3: $min_copies3  max_copies3: $max_copies3\n";

	QUERYLOOP: foreach my $cluster_name ( keys %CLUSTER_HASH )
	{
		my $cluster_ref = $CLUSTER_LOOKUP{$cluster_name};
		my $copies1 = 0;
		my $copies2 = 0;
		my $copies3 = 0;

		foreach my $strain ( @$strain_list1 )
		{
			if ( $CLUSTER_HASH{$cluster_name}->{$strain} )
			{  $copies1++;  }
		}

		foreach my $strain ( @$strain_list2 )
		{
			if ( $CLUSTER_HASH{$cluster_name}->{$strain} )
			{  $copies2++;  }
		}

		foreach my $strain ( @$strain_list3 )
		{
			if ( $CLUSTER_HASH{$cluster_name}->{$strain} )
			{  $copies3++;  }
		}

		if (	($copies1 <= $max_copies1   and  $min_copies1 <= $copies1)
					and
				($copies2 <= $max_copies2   and  $min_copies2 <= $copies2)
					and
				($copies3 <= $max_copies3   and  $min_copies3 <= $copies3)
			)
		{
		    # use this to get cluster name only
		    # print STDOUT "$cluster_ref->{name}\n";

		    # use this block to get sequence from representative strain
			foreach my $seq_obj ( $cluster_ref->{genes}->getAllRefs )
			{
				if ( $seq_obj->name =~ $rep_strain )
				{
					$seq_obj->writeFasta(*STDOUT{IO});
				}
			}
		}
	}
	print STDOUT "<report stop>\n";
	return;
}


#####
#####
#####


sub clusterSearch
{
	print STDOUT "<report clusterSearch>\n";

	# get references to group lists
	my $groupA = shift;
	my $groupB = shift;

	# get threshold parameters for group hits
	my $thresholdA = shift;
	my $thresholdB = shift;

	# get print list parameter
	my $printList = shift;

	# get mode parameter
	my $mode = shift;

	# get description parameter
	my $description = shift;


	# define groupA, groupB strings
	my $groupAstring = join ",", @$groupA;
	my $groupBstring = join ",", @$groupB;

	# declare local variables
	my $totalMatches = 0;
	my %matchClusters = ();

	# find clusters matching search criteria, save to %matchClusters
	CLUSTERLOOP: foreach my $cluster ( keys %CLUSTER_HASH )
	{
		# reset counting variables
		my $strainHitsA = [];
		my $strainHitsB = [];

		# count the occurences of this cluster in groupA
		foreach my $strainA ( @$groupA )
		{
			push @$strainHitsA, $strainA if ( $CLUSTER_HASH{$cluster}{$strainA} );
		}

		# check groupA threshold criteria
		next CLUSTERLOOP if ( @$strainHitsA / @$groupA < $thresholdA );

		# count occurences of this cluster in groupB
		foreach my $strainB ( @$groupB )
		{
			push @$strainHitsB, $strainB if ( $CLUSTER_HASH{$cluster}{$strainB} );
		}

		if ( $mode =~ 'contrast' )
		{
			# check groupB threshold criter
			next CLUSTERLOOP if ( @$strainHitsB / @$groupB > $thresholdB );
		}
		elsif ( $mode =~ 'compare' )
		{
			# check groupB threshold criter
			next CLUSTERLOOP if ( @$strainHitsB / @$groupB < $thresholdB );
		}

		$totalMatches++;
		$matchClusters{$cluster} = [ $strainHitsA, $strainHitsB ];
		next CLUSTERLOOP;
	} # end CLUSTERLOOP

	# print report header info
	print STDOUT "description: $description\n";
	print STDOUT "groupA:\t$groupAstring\n";
	print STDOUT "groupB:\t$groupBstring\n";
	print STDOUT "thresholdA:\t$thresholdA\n";
	print STDOUT "thresholdB:\t$thresholdB\n";
	print STDOUT "mode:\t$mode\n";
	print STDOUT "totalMatches:\t$totalMatches\n";

	if ($printList)
	{
		foreach my $cluster ( sort keys %matchClusters )
		{
			my $lineOutput = "$cluster\t";
			$lineOutput .= scalar(@{$matchClusters{$cluster}->[0]});
			$lineOutput .= "\t";
			$lineOutput .= scalar(@{$matchClusters{$cluster}->[1]});
			$lineOutput .= "\t";
			$lineOutput .= join ",", @{$matchClusters{$cluster}->[0]};
			$lineOutput .= "\t";
			$lineOutput .= join ",", @{$matchClusters{$cluster}->[1]};
			$lineOutput .= "\n";
			print STDOUT $lineOutput;
		}
	}

	print STDOUT "</report>\n";
	return $totalMatches;
}


#####
#####
#####


sub makeVectorOutput
{
	# make vector output for dendrogram clustering
	my $vectorFile = shift;

	open VEC, ">", $vectorFile or die "There was a problem opening the vector file: $!";
	print VEC "# vector data\n";
	print VEC "$TOTAL_CLUSTERS\n";

	foreach my $strain (@STRAIN_LIST)
	{
		print VEC "# label\n$strain\n# data\n";

		foreach my $cluster ( keys %CLUSTER_HASH )
		{
			if ( $CLUSTER_HASH{$cluster}{$strain} )
			{ print VEC "1\n"; }
			else
			{ print VEC "0\n"; }
		}
	}
	close VEC;
	return;
}


#####
#####
#####


sub makeDifferenceOutput
{
	# make difference output for dendrogram clustering
	# get arguments
	my $diffFile = shift;

	# open diffFile for output
	open DIF, ">", $diffFile  or  die "ERROR (makeDifferenceOutput): could not open file $diffFile for output!\n";

	print DIF "$TOTAL_STRAINS\n";
	foreach my $strain (@STRAIN_LIST)
	{ print DIF "$strain\n"; }

	for ( my $index1=0; $index1 < $TOTAL_STRAINS; $index1++ )
	{
		my $strain1 = $STRAIN_LIST[$index1];
		for ( my $index2=$index1 + 1; $index2 < $TOTAL_STRAINS; $index2++ )
		{
			my $strain2 = $STRAIN_LIST[$index2];
			my $difference = 0;

			foreach my $cluster ( keys %CLUSTER_HASH )
			{
				if (
						( $CLUSTER_HASH{$cluster}{$strain1} and !$CLUSTER_HASH{$cluster}{$strain2} )
							or
						( !$CLUSTER_HASH{$cluster}{$strain1} and $CLUSTER_HASH{$cluster}{$strain2} )
					)
				{ $difference++; }
			}

			print DIF "$difference\n";
		}
	}
	close DIF;
	return;
}


######
######
######


sub factorial
{
	my $n = shift;
	my $fact = 1;

	return undef unless ( $n =~ /^\d+$/ );
	return undef if ( $n < 0 );
	return 1 if ($n == 0);

	for (1..$n)
	{
		$fact *= $n;
	}
	return $fact;
}


######
######
######


sub binomial
{
	my $n = shift;
	my $k = shift;
	my $p = shift;

	return undef unless ( $n =~ /^\d+$/ );
	return undef unless ( $k =~ /^\d+$/ and $k <= $n );
	return undef unless ( $p >= 0 and $p <= 1 );

	return &factorial($n) / (&factorial($k)*&factorial($n-$k)) * $p**$k * (1-$p)**($n-$k);
}


######
######
######


sub binomialSum
{
	my $n = shift;
	my $k = shift;
	my $p = shift;

	my $binom = 0;

	return undef unless ( $n =~ /^\d+$/ );
	return undef unless ( $k =~ /^\d+$/ and $k <= $n );
	return undef unless ( $p >= 0 and $p <= 1 );

	for (my $i = 0; $i <= $k; $i++)
	{
		$binom += &binomial($n,$i,$p);
	}
	return $binom;
}


######
######
######


sub load_clusters
{
	# look for start of cluster
	INPUT_LOOP: while ( my $line_input = <STDIN> )
	{
		if ( $line_input =~ /^<cluster start>/ )
		{
			# found cluster; now get cluster name.
			(my $cluster_name) = $line_input =~ /^<cluster start> (\S+)/;

			# create cluster
			my $cluster_ref = new_cluster( $cluster_name );

			# look for start of alignments
			while ( $line_input = <STDIN> )
			{
				if    ( $line_input =~ /<genes start>/ )
				{
					# gather sequences
					my $sequence_input = '';
					while ( $line_input = <STDIN> )
					{
						last if ( $line_input =~ /<genes stop>/ );
						$sequence_input .= $line_input;
					}

					my @sequences = split />/, $sequence_input;
					shift @sequences;  # get rid of blank entry

					foreach my $sequence ( @sequences )
					{
						add_gene_to_cluster( $cluster_ref, Sequence->newFasta(">$sequence") );
					}
				}

				elsif ( $line_input =~ /<alignments start>/ )
				{
					# gather sequences
					my $sequence_input = '';
					while ( $line_input = <STDIN> )
					{
						last if ( $line_input =~ /<alignments stop>/ );
						$sequence_input .= $line_input;
					}

					my @sequences = split />/, $sequence_input;
					shift @sequences;  # get rid of blank entry

					foreach my $sequence ( @sequences )
					{
						add_alignment_to_cluster( $cluster_ref, Sequence->newFasta(">$sequence") );
					}
				}

				elsif ( $line_input =~ /<adjuncts start>/ )
				{
					# gather sequences
					my $sequence_input = '';
					while ( $line_input = <STDIN> )
					{
						last if ( $line_input =~ /<adjuncts stop>/ );
						$sequence_input .= $line_input;
					}

					my @sequences = split />/, $sequence_input;
					shift @sequences;  # get rid of blank entry

					foreach my $sequence ( @sequences )
					{
						add_adjunct_to_cluster( $cluster_ref, Sequence->newFasta(">$sequence") );
					}
				}

				elsif ( $line_input =~ /<strains start>/ )
				{
					while ( $line_input = <STDIN> )
					{
						last if ( $line_input =~ /<strains stop>/ );
						my ($strain, $hit ) = $line_input =~ /([A-Za-z0-9-]+)\t([01])/;
						if ( $hit )
						{
							add_strain_to_cluster( $cluster_ref, $strain );
						}
					}
				}

				elsif ( $line_input =~ /<cluster stop>/ )
				{
					next INPUT_LOOP;
				}
			}
		}
	}

	return;
}


######
######
######


sub new_cluster
{
	# create new cluster structure
	my $cluster_ref
		= {
			'name'       => undef,
			'genes'      => SequenceList->new(),
			'alignments' => SequenceList->new(),
			'adjuncts'   => SequenceList->new(),
			'strains'    => {},
		  };

	foreach my $strain ( @STRAIN_LIST )
	{
		$cluster_ref->{strains}->{$strain} = 0;
	}

	if (@_)
	{
		$cluster_ref->{name} = shift;
	}

	push @CLUSTERS, $cluster_ref;
	return $cluster_ref;
}


######
######
######


sub add_gene_to_cluster
{
	my $cluster_ref = shift;
	foreach my $gene_ref ( @_ )
	{
		# add gene
		$cluster_ref->{genes}->addSequence( $gene_ref );

		# add strain
		my ($strain) = $gene_ref->name =~ /^([A-Za-z0-9-]+)_/;
		$cluster_ref->{strains}->{$strain} = 1;

		# update CLUSTER_INDEX
		$CLUSTER_INDEX{$gene_ref} = $cluster_ref;
	}
	return;
}


######
######
######


sub add_adjunct_to_cluster
{
	my $cluster_ref = shift;
	foreach my $gene_ref ( @_ )
	{
		# add gene
		$cluster_ref->{adjuncts}->addSequence( $gene_ref );

		# add strain
		my ($strain) = $gene_ref->name =~ /^([A-Za-z0-9]+)_/;
		$cluster_ref->{strains}->{$strain} = 1;

		# update CLUSTER_INDEX
		$CLUSTER_INDEX{$gene_ref} = 'adjunct';
	}
	return;
}


######
######
######


sub add_alignment_to_cluster
{
	my $cluster_ref = shift;
	foreach my $gene_ref ( @_ )
	{
		# add alignment
		$cluster_ref->{alignments}->addSequence( $gene_ref );
	}
	return;
}


######
######
######


sub add_strain_to_cluster
{
	my $cluster_ref = shift;
	foreach my $strain ( @_ )
	{
		# add strain
		$cluster_ref->{strains}->{$strain} = 1;
	}
	return;
}


######
######
######


sub output_cluster
{
	my $cluster_ref = shift;

	print STDOUT "<cluster start> $cluster_ref->{name}\n";
	print STDOUT "  <genes start>\n";
	foreach my $gene_ref ( sort $cluster_ref->{genes}->getAllRefs )
	{
		$gene_ref->writeFasta( *STDOUT{IO} );
	}
	print STDOUT "  <genes stop>\n";

	if ( defined $cluster_ref->{alignments} )
	{
		print STDOUT "  <alignments start>\n";
		foreach my $gene_ref ( sort $cluster_ref->{alignments}->getAllRefs )
		{
			$gene_ref->writeFasta( *STDOUT{IO} );
		}
		print STDOUT "  <alignments stop>\n";
	}

	print STDOUT "  <adjuncts start>\n";
	foreach my $gene_ref ( sort $cluster_ref->{adjuncts}->getAllRefs )
	{
		$gene_ref->writeFasta( *STDOUT{IO} );
	}
	print STDOUT "  <adjuncts stop>\n";

	print STDOUT "  <strains start>\n";
	foreach my $strain ( sort keys %{$cluster_ref->{strains}} )
	{
		print STDOUT "    $strain\t$cluster_ref->{strains}->{$strain}\n";
	}
	print STDOUT "  <strains stop>\n";
	print STDOUT "<cluster stop>\n";

	return;
}

